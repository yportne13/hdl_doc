# 一些关于硬件描述语言的胡言乱语

近些年来，总算开始出现一些 Verilog/SV/VHDL 的挑战者，我看过一些，也深入用过一些。最近又我学习了不少编程语言理论（PLT）方面的知识，趁此假期输出一些暴论。

## Verilog/SV

自 Verilog 诞生之后的这几十年来，编程语言理论有了非常大的进展。以现如今的眼光再来审视 Verilog/SV 的语法，无疑有许多非常糟糕的地方。需要注意的是，以下分析的内容，绝大多数在 Verilog 诞生的那个年代是主流做法，只不过随着时间的推移，软件领域发现了这些做法存在的问题并提出了更优秀的方案。

### 宏

Verilog 宏的实现方式非常简单粗暴，就是在正式的代码解析之前加入一个额外的预处理阶段进行文本替换。相比于如今主流的卫生宏或 multi stage language 这类在解析后的语法树基础上替换的宏，这种预处理宏虽然语法简单，但也引入了不少问题。首先是有可能意外捕获宏外部的变量的问题。比如，你原想在宏内定义一个 x 然后做各种操作，假如恰好你忘记定义 x，同时调用宏的地方又恰好有一个 x，那么就很有可能产生预期外的结果。其次，各类工具拿宏几乎没有任何办法，在工具开始代码解析前几乎已经把宏的信息丢完了，没法告诉你这行代码出错原因是展开 XXX 宏里的 YYY 宏引入的问题。此外，由于宏是跟 filelist 走的，一来可能会在引入别人写的模块的时候无意间引入或修改了某个宏的定义，二来任何一点代码改动都有可能影响到整个工程，导致很多实用工具没法做得很干净，比如现在主流编程语言都会提供实时的代码编写辅助（提示、报错之类），因为这些语言在设计的时候就确保了代码修改的影响范围有限，因此无论工程有多大，代码编辑过程中工具都能提供非常及时的反馈。

更糟糕的是，现代编程语言语法足够优秀，绝大多数功能不需要宏的参与，而 Verilog/SV 需要用到宏的机会则要多得多，更加剧了问题的严重性。

### 语法设计

过去几十年来编程语言层出不穷，有无数的新想法进入新的语言中，也有无数好的不好的设计被总结出来。经过这几十年的大浪淘沙，如今的编程语言设计已经有非常坚实的理论指导，有一些原则性的，比如所设计的特性要尽量正交，避免多种语法实现的功能却是一样的，也有一些具体的，比如模式匹配、adt 等。在这些理论的指导下，如今的编程语言既强大又简洁。虽然没有一个很权威的标准来衡量语法的简洁程度，但我们可以借着知名 parser 库 [Antlr](https://github.com/antlr/grammars-v4) 粗略对比一下。这个库提供了一套规范的文法用来描述任意语言的语法，并给出了一些主流语言的规范描述。其中，python3 用了 1007 行，公认强大灵活的 scala 用了 1383 行，而 Verilog 和 System Verilog 分别用了 2635 行和 4896 行。如此复杂的语法会严重拖慢工具解析代码的速度，再加上语言本身不够强大使得写出来的代码总是过于冗长，极大拖慢了工具解析代码的速度。

### 类型

软件编程语言在不同时期对动态/静态类型以及强类型/弱类型的取舍上发生过数次变化，在 Verilog 诞生那会弱类型还是一个比较流行的做法。现如今，伴随着类型论的充分发展和类型推断算法的完善，静态强类型重新成为了主流。现如今芯片工程师所常用的几个语言几乎都是弱类型或动态类型的语言，因此对类型的认知存在较为严重的脱节。静态强类型语言最实用的能力就是证明正确性，最先进的类型系统已经可以用于证明前沿数学理论（见 lean4）。仿真可以测试非常复杂的行为，但几乎不可能保证覆盖所有的 corner case。而类型则相反，很难借助类型证明复杂的功能逻辑的正确性，但想要确认你的代码不会犯某几类低级问题却非常方便。此外，类型可以在很大程度上替代注释的功能。诸如这个信号隶属于哪个时钟域，这个数是否是有符号数，是否是定点数，整数位有几位，这些信息都可以由类型来承载，并顺带用于检查一些代码正确性。

### 单元测试

软件领域一个把控代码质量的重要手段是单元测试。为了鼓励多写单元测试，绝大多数语言都尽力简化这部分操作。如今的编程语言已经将这部分操作简化到，你只要在测试函数上加一个诸如 `#[test]` 之类的标注，然后点击代码编辑器上弹出来的 test 按键即可开始执行测试。相比芯片领域（经常）完全依赖验证人员跑测试，迭代效率要高不少。

## SpinalHDL/Chisel/BlueSpec 等新兴语言

目前勉强算得上流行的两个新语言就是基于 scala 的两个语言 SpinalHDL 和 Chisel。由于 scala 底子足够好，前面介绍 Verilog 的落后之处基本已经得到解决。但这两门语言至今还处在一个不温不火的情况，我觉得大概还有这么几个地方可以改善。首先是安装起来有点复杂，大多数芯片公司的工作环境都是在断网且开发者没有 root 权限和大部分目录权限的服务器中，如果开发环境简化到一个独立的可执行二进制文件，相信推广起来会简单得多。第二个是在线体验的环境还不够友好，目前 SpinalHDL 仅有一个加载缓慢、连接不稳定又缺乏 language server 支持的在线环境。一个可供参考的优秀例子是软件领域最近新出的 Moonbit 语言的在线体验环境，第三个是过于灵活，这个其实有些矛盾，scala 如果不够灵活，就构造不出像 SpinalHDL/Chisel 这样的库，但这样却又阻止不了设计人员在写代码的时候放飞自我。第四个是 lint 还不够强大。虽然目前这两个语言有一套还不错的 lint，能保证生成的代码能够综合通过，但一方面不是实时的，要等生成 Verilog 时才检查，此时给出的报错信息也不够友好，另一方面检查得不够多，最好能把 spylint 和 cdc 检查的事情全干了。最后是缺乏一套强大的形式化验证工具。如今的语言越来越强调参数化能力，但过于灵活的参数化代码的正确性难以保证，覆盖率等传统指标基本失效。如今定理证明器（尤其是以类型论为基础的证明器）的理论已经较为成熟，而证明过程冗长的问题又有大语言模型能够协助解决，兴许基于定理证明器的形式化验证是一个不错的手段。这里要提一嘴 BlueSpec，这门语言据说有一套非常完善的形式化验证工具，但一来似乎没开源，二来 BlueSpec 语法本身似乎为了形式化验证做了一定妥协，因此不太能被工程师接受。

## FIRRTL/LLHD/CIRCT

LLVM，一个软件领域很成功的例子，其定义了一套中间层语言 LLVM IR(Intermediate Representation)，其他语言只需要编译到这个 LLVM IR 上，剩下的就可以放心交给 LLVM 去处理了，只要你能确保给出的 LLVM IR 是最优的，LLVM 就能保证编译出和 C 语言性能相当的程序。这套方法大大简化了编译器开发难度，目前已经有很多成功的例子，比如给老语言开发新编译器的 C++ Clang，比如新语言 Rust Swift 等。于是硬件领域有样学样整出了 FIRRTL 和 LLHD。但我个人觉得这俩玩意目的不纯，要我说把 Verilog 做个删减（把不可综合的语法删掉，再把 function 之类非必须的语法删掉即可，不妨称这样的语言为 V--）就足以作为这个中间层语言。实际上软件领域在 LLVM 诞生前也有人想过用精简的 C 作为中间层语言，比较出名的就是 Haskell，先编译到他们起名为 C-- 的语言上，然后再用 C 编译器完成剩下的编译步骤。但 C 语言有个问题是抽象程度还是不够低，没法足够精确控制生成的汇编代码，迫不得已才诞生了 LLVM IR。Verilog 可不一样，网表都能用 Verilog 语法表示出来。实际上 FIRRTL 的语法几乎可以说是 Verilog 强行换了个样子。用 V-- 的好处自不必多说，工程师不用重新学，所有现有工具直接可以用。至于我前面说的目的不纯也很好理解，如果用 V-- 的话老牌 EDA 厂屹立不倒，新 EDA 厂永无出头之日，所以另起炉灶（FIRRTL、LLHD）也就不难理解。

还有一点比较奇怪的是 FIRRTL/LLHD 普遍喜欢分好多层，这个路子我也觉得不太对。高层次 IR 和语言本身的特性强相关，最低的那个层次约定好就行，高的几个层次各自语言各自实现即可。实际上软件就是这么干的，LLVM 只约定了最低层次的 LLVM IR，Rust 自定义了 HIR 和 MIR，swift 则自定义了 SIL。

## 抽象

似乎芯片领域的工程师普遍有个误解，认为抽象一定会带来 PPA 损失。有一个广为 C++/Rust/Zig 程序员熟知的概念，叫零成本抽象。这个概念用芯片工程师更容易理解的方式来解释就是，当我理解某一个（符合零成本抽象原则的）抽象时，我可以基于此写出很简洁的代码，且这段代码最终生成的 Verilog 是最优的，即使直接写 Verilog 也不可能写出 PPA 更好的结果。抽象层次的提高并不意味着一定是从 gate level 提高到 rtl 再到 behaviour level，只要是常见的结构，都可以从中提取出抽象。

顺便举一个简单的例子来介绍一下面向对象。比如你需要实现一个非常复杂的算法。但你发现在这个算法中，对于数据你只用到了加法和乘法这两种操作。那么只要你在实现这个算法的时候，所有数据加法用 Add 模块，乘法用 Mul 模块，无论将来你的算法需要用浮点数、定点数还是 A 律 13 折之类稀奇古怪的数据类型，你都只需要写出对应的 Add 和 Mul 两个模块，其他代码一行都不用动。面向对象的理念本身不受语言的约束，上面这套操作对应 Verilog 也不过是在 filelist 开头选择到底是引入 src/float/add.v 还是 src/fixed/add.v。只不过语言原生提供支持的情况下能提供更多检查，比如能避免在算法实现的过程中忘记调用 Add 模块直接写了个 +，或者给某个数据类型只实现了 Add 忘记实现 Mul，等等。

## 总结

我们需要再创造一门新语言
